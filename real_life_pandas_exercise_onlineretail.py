# -*- coding: utf-8 -*-
"""Real_Life_Pandas_Exercise_OnlineRetail.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YwGKPTiZFsv7rfs61Kslo4cLUvG8dnMf

# 🛍️ Online Retail Dataset
Dataset Source: Check Whatsapp Group

This notebook contains real-world pandas exercises using a retail transaction dataset. Each section has:
- A question
- A code cell for you to write your answer
- A sample output below the code block for reference (commented)

📁 **Before starting:** Make sure you have downloaded the `OnlineRetail.xlsx` file and placed it in the same folder as this notebook.

### 1. Load the dataset and display the first 5 rows.
📌 Use `pd.read_excel()` and parse dates. #Try parse_dates arg from pd.read_excel() function
"""

# Parse dates keyword is used to indicate which column should be treated as date
import pandas as pd
import numpy as np
retail = pd.read_excel('Online_Retail.xlsx', parse_dates=['InvoiceDate'])
retail.head()

"""### 2. Create a new column `TotalPrice` = `Quantity` × `UnitPrice` using `.apply()`."""

# in teh dataframe retail creating a new column
# axis = 1 makes sue the derivation is applied for each row (default application is axis = 0 which is at column level)
retail['TotalPrice'] = retail.apply(lambda x: x['Quantity'] * x['UnitPrice'], axis=1)
retail.head()

retail.shape

"""### 3. Filter all transactions where `TotalPrice` is above £1000."""

# Total Price is a derived column in the retail dataframe
retail[retail['TotalPrice'] > 1000]

"""### 4. Sort the dataset by `TotalPrice` in descending order."""

# functions of the dataframe are gettin gloaded automatically in the Colab
retail.sort_values('TotalPrice', ascending=False)

"""### 5. Group the data by `Country` and compute total `Quantity` and `TotalPrice`."""

retail[['Country','Quantity', 'TotalPrice']].groupby('Country').sum().sort_values('Country', ascending=False)



"""### 6. Find the top 5 customers by total spend."""

# customerID has NaN values.
# First get them fropped from the data set to have only valid values
retail.dropna(subset=['CustomerID'], inplace=True)
retail

# converting the CustomerID column to a valid integer value
retail['CustomerID'] = retail['CustomerID'].astype(int)
retail

retail[['CustomerID', 'TotalPrice']].groupby('CustomerID').sum().sort_values('TotalPrice', ascending=False).head(5)

retail

retail['InvoiceDate'].dt.month

"""### 7. Extract the month from `InvoiceDate` and count transactions per month."""

retail['month'] = retail['InvoiceDate'].dt.month
retail

# new column of the data frame month is derived in above steps
retail[['month', 'InvoiceNo']].groupby('month').count()

"""### 8. Filter transactions from the UK with positive `Quantity`."""

# How quantity can be negative?
# & condition is very import to be used (AND is NOT working)
retail[(retail['Country'] == 'United Kingdom') & (retail['Quantity'] > 0)]

"""### 9. Create a column `ValueLabel` as 'High' if `TotalPrice` > 500 else 'Low'."""

retail['ValueLabel'] = retail['TotalPrice'].apply(lambda x: 'High' if x > 500 else 'Low')
retail.head(5)

"""### 10. Count number of `High` value transactions by country."""

# filter by valuelabel = 'High' and group by the country column and use count aggregate function
retail[['Country', 'ValueLabel']][(retail['ValueLabel'] == 'High')].groupby('Country').count()

retail[['Country', 'ValueLabel']].groupby('Country').count()

